import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import { GoogleGenerativeAI } from "@google/generative-ai";
import pdfParse from "pdf-parse";
import * as mammoth from "mammoth";
import { createWorker } from "tesseract.js";
import * as crypto from "crypto";
import * as dotenv from "dotenv";
import { config } from "./config";

// Load environment variables
dotenv.config();

// Initialize Firebase Admin SDK
admin.initializeApp();

// Initialize Firestore
const db = admin.firestore();

// Initialize Google AI (Gemini)
const genAI = new GoogleGenerativeAI(config.gemini.apiKey);

// Admin service functions for data migration and seeding
export const seedAdminData = functions.https.onCall(async (data: any, context: any) => {
    try {
        // Verify admin access
        if (!context?.auth) {
            throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
        }

        const userRecord = await admin.auth().getUser(context.auth.uid);
        if (userRecord.customClaims?.role !== 'admin') {
            throw new functions.https.HttpsError('permission-denied', 'Admin access required');
        }

        // Create initial admin settings
        const adminSettingsRef = db.collection('adminSettings').doc('default');
        const existingSettings = await adminSettingsRef.get();
        
        if (!existingSettings.exists) {
            const defaultSettings = {
                id: 'default',
                platformName: 'Home Listing AI',
                platformUrl: 'https://homelistingai.com',
                supportEmail: 'support@homelistingai.com',
                timezone: 'UTC',
                featureToggles: {
                    aiContentGeneration: true,
                    voiceAssistant: true,
                    qrCodeSystem: true,
                    analyticsDashboard: true,
                    knowledgeBase: true
                },
                systemLimits: {
                    maxFileUploadSize: 10485760, // 10MB
                    sessionTimeout: 24,
                    maxConcurrentUsers: 1000,
                    apiRateLimit: 100
                },
                maintenanceMode: false,
                autoUpdates: true
            };
            await adminSettingsRef.set(defaultSettings);
        }

        // Set up default retention campaigns
        const campaignsRef = db.collection('retentionCampaigns');
        const existingCampaigns = await campaignsRef.get();
        
        if (existingCampaigns.empty) {
            const defaultCampaigns = [
                {
                    name: 'Pre-Renewal Reminder',
                    trigger: 'pre-renewal',
                    triggerDays: 3,
                    channels: ['email', 'push'],
                    messageTemplate: 'Your subscription renews in {days} days. Upgrade now to continue using all features!',
                    successRate: 0,
                    isActive: true,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                },
                {
                    name: 'Renewal Day Recovery',
                    trigger: 'renewal-day',
                    triggerDays: 0,
                    channels: ['email'],
                    messageTemplate: 'We miss you! Come back and check out your latest leads and properties.',
                    successRate: 0,
                    isActive: true,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                },
                {
                    name: 'Day 1 Recovery',
                    trigger: 'day-1-recovery',
                    triggerDays: 1,
                    channels: ['email', 'push'],
                    messageTemplate: 'Your subscription has expired. Renew now to ensure uninterrupted access to your account.',
                    successRate: 0,
                    isActive: true,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                }
            ];

            for (const campaign of defaultCampaigns) {
                await campaignsRef.add(campaign);
            }
        }

        // Create system monitoring rules
        const monitoringRulesRef = db.collection('systemMonitoringRules');
        const existingRules = await monitoringRulesRef.get();
        
        if (existingRules.empty) {
            const defaultRules = [
                {
                    id: 'high_cpu_usage',
                    name: 'High CPU Usage Alert',
                    type: 'system_performance',
                    condition: 'cpu_usage > 80',
                    severity: 'warning',
                    isActive: true,
                    action: 'send_alert'
                },
                {
                    id: 'database_connection_issues',
                    name: 'Database Connection Issues',
                    type: 'system_health',
                    condition: 'db_connection_failed',
                    severity: 'error',
                    isActive: true,
                    action: 'send_alert'
                },
                {
                    id: 'api_response_time',
                    name: 'API Response Time Alert',
                    type: 'system_performance',
                    condition: 'api_response_time > 2000ms',
                    severity: 'warning',
                    isActive: true,
                    action: 'send_alert'
                }
            ];

            for (const rule of defaultRules) {
                await monitoringRulesRef.doc(rule.id).set(rule);
            }
        }

        return {
            success: true,
            message: 'Admin data seeded successfully',
            createdItems: {
                adminSettings: !existingSettings.exists,
                retentionCampaigns: existingCampaigns.empty,
                systemMonitoringRules: existingRules.empty
            }
        };
    } catch (error) {
        console.error('Seed admin data error:', error);
        throw new functions.https.HttpsError('internal', `Failed to seed admin data: ${error}`);
    }
});

export const migrateUserData = functions.https.onCall(async (data: any, context: any) => {
    try {
        // Verify admin access
        if (!context?.auth) {
            throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
        }

        const userRecord = await admin.auth().getUser(context.auth.uid);
        if (userRecord.customClaims?.role !== 'admin') {
            throw new functions.https.HttpsError('permission-denied', 'Admin access required');
        }

        const usersRef = db.collection('users');
        const usersSnapshot = await usersRef.get();
        let migratedUsers = 0;
        const errors: string[] = [];
        const updatedFields: string[] = [];

        for (const userDoc of usersSnapshot.docs) {
            try {
                const userData = userDoc.data();
                const updates: any = {};

                // Update existing users with new fields
                if (!userData.dateJoined) {
                    updates.dateJoined = new Date().toISOString();
                    updatedFields.push('dateJoined');
                }

                if (!userData.lastActive) {
                    updates.lastActive = new Date().toISOString();
                    updatedFields.push('lastActive');
                }

                if (!userData.propertiesCount) {
                    updates.propertiesCount = 0;
                    updatedFields.push('propertiesCount');
                }

                if (!userData.leadsCount) {
                    updates.leadsCount = 0;
                    updatedFields.push('leadsCount');
                }

                if (!userData.aiInteractions) {
                    updates.aiInteractions = 0;
                    updatedFields.push('aiInteractions');
                }

                if (!userData.renewalDate) {
                    const renewalDate = new Date();
                    renewalDate.setDate(renewalDate.getDate() + 30); // Default 30 days
                    updates.renewalDate = renewalDate.toISOString();
                    updatedFields.push('renewalDate');
                }

                if (!userData.subscriptionStatus) {
                    updates.subscriptionStatus = 'trial';
                    updatedFields.push('subscriptionStatus');
                }

                if (!userData.plan) {
                    updates.plan = 'Solo Agent';
                    updatedFields.push('plan');
                }

                if (!userData.status) {
                    updates.status = 'Active';
                    updatedFields.push('status');
                }

                // Apply updates if any
                if (Object.keys(updates).length > 0) {
                    await userDoc.ref.update(updates);
                    migratedUsers++;
                }
            } catch (error) {
                errors.push(`Failed to migrate user ${userDoc.id}: ${error}`);
            }
        }

        // Calculate user statistics
        const totalUsers = usersSnapshot.size;
        const activeUsers = usersSnapshot.docs.filter(doc => doc.data().status === 'Active').length;
        const trialUsers = usersSnapshot.docs.filter(doc => doc.data().subscriptionStatus === 'trial').length;
        const expiredUsers = usersSnapshot.docs.filter(doc => doc.data().subscriptionStatus === 'expired').length;

        // Log migration results
        console.log(`Migration completed: ${migratedUsers} users migrated`);

        // Set up subscription tracking - identify high risk users
        const highRiskUsers = usersSnapshot.docs.filter(doc => {
            const userData = doc.data();
            const lastActiveDate = new Date(userData.lastActive || new Date());
            const now = new Date();
            const daysSinceLastActive = Math.floor((now.getTime() - lastActiveDate.getTime()) / (1000 * 60 * 60 * 24));
            
            return daysSinceLastActive > 30 || userData.propertiesCount === 0;
        });

        if (highRiskUsers.length > 0) {
            // Create system alert for high risk users
            await db.collection('systemAlerts').add({
                type: 'warning',
                title: 'High Risk Users Detected',
                description: `${highRiskUsers.length} users identified as high risk for churn`,
                severity: 'high',
                component: 'user_management',
                createdAt: new Date().toISOString(),
                status: 'active'
            });
        }

        return {
            success: true,
            message: `Successfully migrated ${migratedUsers} users`,
            migratedUsers,
            updatedFields: [...new Set(updatedFields)],
            errors,
            stats: {
                totalUsers,
                activeUsers,
                trialUsers,
                expiredUsers
            }
        };
    } catch (error) {
        console.error('Migration error:', error);
        throw new functions.https.HttpsError('internal', `Migration failed: ${error}`);
    }
});

// Set admin role for a user
export const setAdminRole = functions.https.onCall(async (data: any, context: any) => {
    try {
        // Verify admin access
        if (!context?.auth) {
            throw new functions.https.HttpsError('unauthenticated', 'Authentication required');
        }

        const { email } = data;
        if (!email) {
            throw new functions.https.HttpsError('invalid-argument', 'Email is required');
        }

        // Check if the requesting user is already an admin or if this is the first admin setup
        const requestingUser = await admin.auth().getUser(context.auth.uid);
        
        // For security, only allow setting admin role if:
        // 1. The requesting user is already an admin, OR
        // 2. This is the first admin setup (no existing admins)
        const existingAdmins = await db.collection('users')
            .where('role', '==', 'admin')
            .get();

        const isFirstAdmin = existingAdmins.empty;
        const isRequestingUserAdmin = requestingUser.customClaims?.role === 'admin';

        if (!isFirstAdmin && !isRequestingUserAdmin) {
            throw new functions.https.HttpsError('permission-denied', 'Only existing admins can create new admins');
        }

        // Find the user by email
        const userRecord = await admin.auth().getUserByEmail(email);
        
        // Set custom claims for admin role
        await admin.auth().setCustomUserClaims(userRecord.uid, {
            role: 'admin',
            permissions: ['users', 'billing', 'analytics', 'system', 'support']
        });

        // Update user document in Firestore
        await db.collection('users').doc(userRecord.uid).set({
            role: 'admin',
            isAdmin: true,
            adminPermissions: ['users', 'billing', 'analytics', 'system', 'support'],
            updatedAt: new Date().toISOString()
        }, { merge: true });

        return {
            success: true,
            message: `Admin role set successfully for ${email}`
        };
    } catch (error) {
        console.error('Set admin role error:', error);
        throw new functions.https.HttpsError('internal', `Failed to set admin role: ${error}`);
    }
});

// Export the setup admin function
export { setupInitialAdmin, setupInitialAdminHttp } from './setupAdmin';

// Test function to verify deployment
export const testAddUser = functions.https.onCall(async (data: any, context: any) => {
    try {
        console.log('testAddUser called with data:', data);
        console.log('Data type:', typeof data);
        console.log('Data keys:', Object.keys(data || {}));
        
        // For now, just return success to test if the function is being called
        console.log('Function called successfully');
        return {
            success: true,
            message: 'Test function call successful',
            data: data
        };
    } catch (error: any) {
        console.error('Test function error:', error);
        throw new functions.https.HttpsError('internal', `Test function error: ${error.message || error}`);
    }
});

// Add new user function (callable version)
export const addNewUser = functions.https.onCall(async (data: any, context: any) => {
    try {
        console.log('addNewUser called with data:', data);
        console.log('Data type:', typeof data);
        console.log('Data keys:', Object.keys(data || {}));
        
        // Extract the data from the nested structure
        const userData = data.data || data;
        const { email, password, name, role = 'agent', plan = 'Solo Agent' } = userData;
        
        console.log('Extracted data:', { email, password: password ? '***' : 'missing', name, role, plan });
        
        if (!email || !password || !name) {
            console.log('Missing required fields:', { email: !!email, password: !!password, name: !!name });
            throw new functions.https.HttpsError('invalid-argument', 'Email, password, and name are required');
        }

        console.log('Creating user with:', { email, name, role, plan });

        // Check if user already exists
        try {
            const existingUser = await admin.auth().getUserByEmail(email);
            if (existingUser) {
                console.log('User already exists:', email);
                throw new functions.https.HttpsError('already-exists', 'User already exists with this email');
            }
        } catch (error: any) {
            if (error.code === 'auth/user-not-found') {
                // User doesn't exist, which is what we want
                console.log('User does not exist, proceeding with creation');
            } else {
                console.error('Error checking existing user:', error);
                throw new functions.https.HttpsError('internal', `Firebase Auth error: ${error.message}`);
            }
        }

        // Create the user using Firebase Auth
        console.log('Creating Firebase Auth user...');
        const userRecord = await admin.auth().createUser({
            email: email,
            password: password,
            displayName: name,
            emailVerified: false
        });

        console.log('Firebase Auth user created:', userRecord.uid);

        // Set custom claims based on role
        const customClaims = {
            role: role,
            permissions: role === 'admin' ? ['users', 'billing', 'analytics', 'system', 'support'] : ['basic']
        };
        
        console.log('Setting custom claims:', customClaims);
        await admin.auth().setCustomUserClaims(userRecord.uid, customClaims);

        // Create user document in Firestore
        console.log('Creating Firestore user document...');
        const db = admin.firestore();
        const userDoc = {
            id: userRecord.uid,
            name: name,
            email: email,
            status: 'Active',
            role: role,
            plan: plan,
            propertiesCount: 0,
            leadsCount: 0,
            aiInteractions: 0,
            subscriptionStatus: 'trial',
            dateJoined: new Date().toISOString(),
            lastActive: new Date().toISOString(),
            renewalDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
        };

        await db.collection('users').doc(userRecord.uid).set(userDoc);
        console.log('Firestore user document created');

        console.log('User creation completed successfully');
        return {
            success: true,
            message: `User ${name} created successfully`,
            userId: userRecord.uid,
            email: email
        };
    } catch (error: any) {
        console.error('Add user error:', error);
        console.error('Error details:', {
            code: error.code,
            message: error.message,
            stack: error.stack
        });
        throw new functions.https.HttpsError('internal', `Failed to add user: ${error.message || error}`);
    }
});



// Import the CORS middleware
import { applyCors } from './middleware';

// HTTP version of addNewUser with CORS support
export const addNewUserHttp = functions.https.onRequest(async (req, res) => {
    // Apply CORS middleware
    await applyCors(req, res);
    
    // Only allow POST requests
    if (req.method !== 'POST') {
        res.status(405).send('Method Not Allowed');
        return;
    }
    
    try {
        console.log('addNewUserHttp called with body:', req.body);
        
        const { email, password, name, role = 'agent', plan = 'Solo Agent' } = req.body;
        
        if (!email || !password || !name) {
            console.log('Missing required fields:', { email: !!email, password: !!password, name: !!name });
            res.status(400).json({ 
                success: false, 
                error: 'Email, password, and name are required' 
            });
            return;
        }
        
        // Check if user already exists
        try {
            const existingUser = await admin.auth().getUserByEmail(email);
            if (existingUser) {
                console.log('User already exists:', email);
                res.status(409).json({ 
                    success: false, 
                    error: 'User already exists with this email' 
                });
                return;
            }
        } catch (error: any) {
            if (error.code !== 'auth/user-not-found') {
                console.error('Error checking existing user:', error);
                res.status(500).json({ 
                    success: false, 
                    error: `Firebase Auth error: ${error.message}` 
                });
                return;
            }
            // User doesn't exist, which is what we want
            console.log('User does not exist, proceeding with creation');
        }
        
        // Create the user using Firebase Auth
        console.log('Creating Firebase Auth user...');
        const userRecord = await admin.auth().createUser({
            email: email,
            password: password,
            displayName: name,
            emailVerified: false
        });
        
        console.log('Firebase Auth user created:', userRecord.uid);
        
        // Set custom claims based on role
        const customClaims = {
            role: role,
            permissions: role === 'admin' ? ['users', 'billing', 'analytics', 'system', 'support'] : ['basic']
        };
        
        console.log('Setting custom claims:', customClaims);
        await admin.auth().setCustomUserClaims(userRecord.uid, customClaims);
        
        // Create user document in Firestore
        console.log('Creating Firestore user document...');
        const db = admin.firestore();
        const userDoc = {
            id: userRecord.uid,
            name: name,
            email: email,
            status: 'Active',
            role: role,
            plan: plan,
            propertiesCount: 0,
            leadsCount: 0,
            aiInteractions: 0,
            subscriptionStatus: 'trial',
            dateJoined: new Date().toISOString(),
            lastActive: new Date().toISOString(),
            renewalDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
        };
        
        await db.collection('users').doc(userRecord.uid).set(userDoc);
        console.log('Firestore user document created');
        
        console.log('User creation completed successfully');
        res.status(200).json({
            success: true,
            message: `User ${name} created successfully`,
            userId: userRecord.uid,
            email: email
        });
    } catch (error: any) {
        console.error('Add user error:', error);
        console.error('Error details:', {
            code: error.code,
            message: error.message,
            stack: error.stack
        });
        res.status(500).json({ 
            success: false, 
            error: `Failed to add user: ${error.message || error}` 
        });
    }
});

// Trigger onboarding sequence function
export const triggerOnboardingSequence = functions.https.onCall(async (data: any, context: any) => {
    try {
        console.log('triggerOnboardingSequence called with data:', data);
        
        const { userEmail, userName } = data;
        
        if (!userEmail || !userName) {
            throw new functions.https.HttpsError('invalid-argument', 'Email and name are required');
        }
        
        // Create onboarding document in Firestore
        const db = admin.firestore();
        const onboardingDoc = {
            userEmail,
            userName,
            status: 'pending',
            steps: [
                { id: 'welcome_email', status: 'pending', scheduledFor: new Date().toISOString() },
                { id: 'setup_reminder', status: 'pending', scheduledFor: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() },
                { id: 'feature_introduction', status: 'pending', scheduledFor: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString() }
            ],
            createdAt: new Date().toISOString()
        };
        
        const onboardingRef = await db.collection('onboarding').add(onboardingDoc);
        console.log('Onboarding document created with ID:', onboardingRef.id);
        
        return {
            success: true,
            message: 'Onboarding sequence triggered successfully',
            onboardingId: onboardingRef.id
        };
    } catch (error: any) {
        console.error('Trigger onboarding error:', error);
        throw new functions.https.HttpsError('internal', `Failed to trigger onboarding: ${error.message || error}`);
    }
});

// HTTP version of triggerOnboardingSequence with CORS support
export const triggerOnboardingSequenceHttp = functions.https.onRequest(async (req, res) => {
    // Apply CORS middleware
    await applyCors(req, res);
    
    // Only allow POST requests
    if (req.method !== 'POST') {
        res.status(405).send('Method Not Allowed');
        return;
    }
    
    try {
        console.log('triggerOnboardingSequenceHttp called with body:', req.body);
        
        const { userEmail, userName } = req.body;
        
        if (!userEmail || !userName) {
            res.status(400).json({
                success: false,
                error: 'Email and name are required'
            });
            return;
        }
        
        // Create onboarding document in Firestore
        const db = admin.firestore();
        const onboardingDoc = {
            userEmail,
            userName,
            status: 'pending',
            steps: [
                { id: 'welcome_email', status: 'pending', scheduledFor: new Date().toISOString() },
                { id: 'setup_reminder', status: 'pending', scheduledFor: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() },
                { id: 'feature_introduction', status: 'pending', scheduledFor: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString() }
            ],
            createdAt: new Date().toISOString()
        };
        
        const onboardingRef = await db.collection('onboarding').add(onboardingDoc);
        console.log('Onboarding document created with ID:', onboardingRef.id);
        
        res.status(200).json({
            success: true,
            message: 'Onboarding sequence triggered successfully',
            onboardingId: onboardingRef.id
        });
    } catch (error: any) {
        console.error('Trigger onboarding error:', error);
        res.status(500).json({
            success: false,
            error: `Failed to trigger onboarding: ${error.message || error}`
        });
    }
});

// Firestore reference already initialized above




// Convert text to speech using OpenAI TTS


// Generate property description using OpenAI GPT-5.0 with GPT-4.0 mini fallback
export const generatePropertyDescription = functions.https.onCall(async (data: any, context) => {
    try {
        const { property } = data;
        
        // Check OpenAI API key
        if (!process.env.OPENAI_API_KEY) {
            console.error("generatePropertyDescription: OpenAI API key is not configured");
            throw new functions.https.HttpsError("failed-precondition", "AI service is not properly configured");
        }

        const OpenAI = require('openai');
        const openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY
        });
        
        const prompt = `Create a compelling property description for a real estate listing. The property details are:

Title: ${property.title}
Address: ${property.address}
Price: $${property.price?.toLocaleString()}
Bedrooms: ${property.bedrooms}
Bathrooms: ${property.bathrooms}
Square Feet: ${property.squareFeet?.toLocaleString()}
Property Type: ${property.propertyType}
Features: ${property.features?.join(', ')}

Please create a structured description with:
1. A catchy title
2. 3-4 engaging paragraphs highlighting the property's best features
3. Focus on what makes this property special
4. Use persuasive but honest language
5. Include details about the neighborhood if relevant

Format the response as JSON with "title" and "paragraphs" fields.`;

        const messages = [
            {
                role: "system",
                content: "You are a professional real estate copywriter. Create compelling property descriptions that are honest, engaging, and persuasive."
            },
            {
                role: "user",
                content: prompt
            }
        ];

        console.log("generatePropertyDescription: Calling OpenAI GPT-5.0");

        try {
            // Try GPT-5.0 first
            const completion = await openai.chat.completions.create({
                model: "gpt-5",
                messages: messages,
                max_completion_tokens: 2048
            });

            const responseText = completion.choices[0]?.message?.content;
            if (responseText) {
                console.log("generatePropertyDescription: GPT-5.0 response successful");
                
                // Try to parse as JSON, fallback to plain text
                try {
                    return JSON.parse(responseText);
                } catch {
                    return {
                        title: "Property Description",
                        paragraphs: [responseText]
                    };
                }
            }
        } catch (gpt5Error) {
            console.log("generatePropertyDescription: GPT-5.0 failed, trying GPT-4.0 mini fallback");
            
            try {
                // Fallback to GPT-4.0 mini
                const fallbackCompletion = await openai.chat.completions.create({
                    model: "gpt-4o-mini",
                    messages: messages,
                    max_tokens: 2048,
                    temperature: 0.7
                });

                const fallbackResponseText = fallbackCompletion.choices[0]?.message?.content;
                if (fallbackResponseText) {
                    console.log("generatePropertyDescription: GPT-4.0 mini fallback successful");
                    
                    // Try to parse as JSON, fallback to plain text
                    try {
                        return JSON.parse(fallbackResponseText);
                    } catch {
                        return {
                            title: "Property Description",
                            paragraphs: [fallbackResponseText]
                        };
                    }
                }
            } catch (fallbackError) {
                console.error("generatePropertyDescription: Both GPT-5.0 and GPT-4.0 mini failed");
                throw new functions.https.HttpsError("internal", "Failed to generate property description from both models");
            }
        }

        throw new functions.https.HttpsError("internal", "Failed to generate property description");
    } catch (error) {
        console.error("Property description generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate property description");
    }
});

// Answer property questions using OpenAI GPT-5.0 with GPT-4.0 mini fallback
export const answerPropertyQuestion = functions.https.onCall(async (data: any, context) => {
    try {
        const { property, question } = data;
        
        // Check OpenAI API key
        if (!process.env.OPENAI_API_KEY) {
            console.error("answerPropertyQuestion: OpenAI API key is not configured");
            throw new functions.https.HttpsError("failed-precondition", "AI service is not properly configured");
        }

        const OpenAI = require('openai');
        const openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY
        });
        
        const prompt = `You are a helpful real estate assistant. Answer the following question about this property:

Property Details:
- Title: ${property.title}
- Address: ${property.address}
- Price: $${property.price?.toLocaleString()}
- Bedrooms: ${property.bedrooms}
- Bathrooms: ${property.bathrooms}
- Square Feet: ${property.squareFeet?.toLocaleString()}
- Property Type: ${property.propertyType}
- Features: ${property.features?.join(', ')}
- Description: ${property.description?.paragraphs?.join(' ') || property.description}

Question: ${question}

Please provide a helpful, accurate answer based on the property information. Keep it conversational and under 100 words.`;

        const messages = [
            {
                role: "system",
                content: "You are a helpful real estate assistant. Provide accurate, helpful answers about properties based on the information provided."
            },
            {
                role: "user",
                content: prompt
            }
        ];

        console.log("answerPropertyQuestion: Calling OpenAI GPT-5.0");

        try {
            // Try GPT-5.0 first
            const completion = await openai.chat.completions.create({
                model: "gpt-5",
                messages: messages,
                max_completion_tokens: 1024
            });

            const responseText = completion.choices[0]?.message?.content;
            if (responseText) {
                console.log("answerPropertyQuestion: GPT-5.0 response successful");
                return { text: responseText };
            }
        } catch (gpt5Error) {
            console.log("answerPropertyQuestion: GPT-5.0 failed, trying GPT-4.0 mini fallback");
            
            try {
                // Fallback to GPT-4.0 mini
                const fallbackCompletion = await openai.chat.completions.create({
                    model: "gpt-4o-mini",
                    messages: messages,
                    max_tokens: 1024,
                    temperature: 0.7
                });

                const fallbackResponseText = fallbackCompletion.choices[0]?.message?.content;
                if (fallbackResponseText) {
                    console.log("answerPropertyQuestion: GPT-4.0 mini fallback successful");
                    return { text: fallbackResponseText };
                }
            } catch (fallbackError) {
                console.error("answerPropertyQuestion: Both GPT-5.0 and GPT-4.0 mini failed");
                throw new functions.https.HttpsError("internal", "Failed to answer property question from both models");
            }
        }

        throw new functions.https.HttpsError("internal", "Failed to answer property question");
    } catch (error) {
        console.error("Property question error:", error);
        throw new functions.https.HttpsError("internal", "Failed to answer property question");
    }
});



// Generate market analysis using Gemini
export const getMarketAnalysis = functions.https.onCall(async (data: any, context) => {
    try {
        const { address } = data;
        
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Provide a brief market analysis for the area around ${address}. Include:
1. General market trends
2. Average property values
3. Key selling points of the neighborhood
4. Any notable amenities or attractions

Keep it concise and informative for potential buyers.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();

        return { 
            analysisText: text,
            sources: [
                { uri: "https://www.google.com/maps", title: "Google Maps" },
                { uri: "https://www.zillow.com", title: "Zillow Market Data" }
            ]
        };
    } catch (error) {
        console.error("Market analysis error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate market analysis");
    }
});

// Generate comprehensive property report using Gemini
export const generatePropertyReport = functions.https.onCall(async (data: any, context) => {
    try {
        const { property, options } = data;
        
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        console.log("Generating property report for:", property.address);
        
        // Build enhanced property context with real data if available
        let propertyContext = `
        Property Details:
        - Address: ${property.address}
        - Type: ${property.propertyType || 'residential'}
        - Size: ${property.squareFeet?.toLocaleString()} sq ft
        - Bedrooms: ${property.bedrooms}
        - Bathrooms: ${property.bathrooms}
        - Listed Price: $${property.price?.toLocaleString()}
        - Features: ${property.features?.join(', ') || 'Standard features'}
        `;
        
        // Add real property data if available
        if (options.realPropertyData) {
            const realData = options.realPropertyData;
            propertyContext += `
        
        Real Market Data (Enhanced with Datafiniti):
        - Estimated Value: $${realData.estimatedValue?.toLocaleString() || 'N/A'}
        - Rental Estimate: $${realData.rentEstimate?.toLocaleString() || 'N/A'}/month
        - Walk Score: ${realData.walkScore || 'N/A'}/100
        - Safety Score: ${realData.crimeScore || 'N/A'}/100
        - School District: ${realData.schoolDistrict || 'N/A'}
        - Neighborhood: ${realData.neighborhood || 'N/A'}
        - Year Built: ${realData.yearBuilt || 'N/A'}
        - Lot Size: ${realData.lotSize?.toLocaleString() || 'N/A'} sq ft
        `;
        }
        
        // Build content sections based on selected options
        let contentSections = [];
        
        if (options.marketAnalysis) {
            contentSections.push("## Market Analysis\nProvide current market conditions, pricing trends, and market positioning for this property type and area.");
        }
        
        if (options.comparableProperties) {
            contentSections.push("## Comparable Properties\nAnalyze similar properties in the area, comparing features, pricing, and market performance.");
        }
        
        if (options.neighborhoodInfo) {
            contentSections.push("## Neighborhood Highlights\nDescribe the neighborhood amenities, schools, transportation, and lifestyle factors that make this area attractive.");
        }
        
        const prompt = `Create a professional real estate market report for this property:
        
        ${propertyContext}
        
        Generate a comprehensive report with the following sections:
        ${contentSections.join('\n\n')}
        
        ## Investment Summary
        Provide an overall investment recommendation and key takeaways.
        
        Requirements:
        - Professional tone suitable for client presentations
        - Use actual data provided where available
        - Include specific numbers and market insights
        - Format with clear headings and bullet points
        - 800-1200 words total
        - Focus on value proposition and market opportunity
        
        Make this report compelling for potential buyers or investors while remaining factual and professional.`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log("Property report generated successfully");
        return { text };
    } catch (error) {
        console.error("Property report generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate property report");
    }
});

// Generate blog post using Gemini
export const generateBlogPost = functions.https.onCall(async (data: any, context) => {
    try {
        const { topic, tone, length } = data;
        
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Write a ${tone} blog post about ${topic} for a real estate website. The post should be approximately ${length} words long. Make it engaging, informative, and valuable for potential homebuyers or sellers.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();

        return { 
            title: `Real Estate Insights: ${topic}`,
            body: text
        };
    } catch (error) {
        console.error("Blog post generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate blog post");
    }
});

// Generate social media post using Gemini
export const generateSocialPostText = functions.https.onCall(async (data: any, context) => {
    try {
        const { property, platform, tone } = data;
        
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Create a ${tone} social media post for ${platform} about this property:

Property: ${property.title}
Address: ${property.address}
Price: $${property.price?.toLocaleString()}
Key Features: ${property.features?.slice(0, 3).join(', ')}

Make it engaging, include relevant hashtags, and encourage engagement. Keep it appropriate for ${platform}.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();

        return { text };
    } catch (error) {
        console.error("Social post generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate social post");
    }
});

// Get local information using Gemini
export const getLocalInfo = functions.https.onCall(async (data: any, context) => {
    try {
        const { address, category } = data;
        
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Provide information about ${category} near ${address}. Include:
1. A brief summary of the area
2. Key highlights about ${category}
3. Notable features or attractions
4. Any relevant local insights

Focus on information that would be valuable for potential homebuyers.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();

        return {
            summary: text,
            category: category,
            highlights: text.split('. ').slice(0, 3),
            sources: [
                { uri: `https://www.google.com/maps/search/${encodeURIComponent(category + ' ' + address)}`, title: "Google Maps" }
            ],
            lastUpdated: new Date().toISOString()
        };
    } catch (error) {
        console.error("Local info error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get local information");
    }
});

// ========================================
// FILE UPLOAD & STORAGE SYSTEM
// ========================================

// Initialize Firebase Storage
const bucket = admin.storage().bucket();

// File upload handler
export const uploadFile = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { file, fileName, fileType, userId, propertyId } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Validate file type
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'text/plain'];
        if (!allowedTypes.includes(fileType)) {
            throw new functions.https.HttpsError("invalid-argument", "File type not supported");
        }

        // Create file path
        const filePath = `uploads/${userId}/${propertyId || 'general'}/${Date.now()}_${fileName}`;
        
        // Upload to Firebase Storage
        const fileBuffer = Buffer.from(file, 'base64');
        const fileUpload = bucket.file(filePath);
        
        await fileUpload.save(fileBuffer, {
            metadata: {
                contentType: fileType,
                metadata: {
                    uploadedBy: userId,
                    propertyId: propertyId || null,
                    uploadedAt: new Date().toISOString()
                }
            }
        });

        // Get download URL
        const [url] = await fileUpload.getSignedUrl({
            action: 'read',
            expires: '03-01-2500'
        });

        // Store file metadata in Firestore
        const fileDoc = await db.collection('files').add({
            fileName,
            fileType,
            filePath,
            downloadUrl: url,
            uploadedBy: userId,
            propertyId: propertyId || null,
            uploadedAt: admin.firestore.FieldValue.serverTimestamp(),
            status: 'uploaded',
            size: fileBuffer.length
        });

        return {
            fileId: fileDoc.id,
            fileName,
            downloadUrl: url,
            status: 'success'
        };
    } catch (error) {
        console.error("File upload error:", error);
        throw new functions.https.HttpsError("internal", "Failed to upload file");
    }
});

// Process document and extract text
export const processDocument = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { fileId, fileType } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get file from Firestore
        const fileDoc = await db.collection('files').doc(fileId).get();
        if (!fileDoc.exists) {
            throw new functions.https.HttpsError("not-found", "File not found");
        }

        const fileData = fileDoc.data();
        const filePath = fileData?.filePath;

        // Download file from Storage
        const file = bucket.file(filePath);
        const [fileBuffer] = await file.download();

        let extractedText = '';

        // Process based on file type
        switch (fileType) {
            case 'application/pdf':
                const pdfData = await pdfParse(fileBuffer);
                extractedText = pdfData.text;
                break;

            case 'application/msword':
            case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
                const result = await mammoth.extractRawText({ buffer: fileBuffer });
                extractedText = result.value;
                break;

            case 'text/plain':
                extractedText = fileBuffer.toString('utf-8');
                break;

            case 'image/jpeg':
            case 'image/png':
            case 'image/gif':
                // OCR for images
                const worker = await createWorker();
                await worker.loadLanguage('eng');
                await worker.initialize('eng');
                const { data: { text } } = await worker.recognize(fileBuffer);
                await worker.terminate();
                extractedText = text;
                break;

            default:
                throw new functions.https.HttpsError("invalid-argument", "File type not supported for text extraction");
        }

        // Update file document with extracted text
        await db.collection('files').doc(fileId).update({
            extractedText,
            processedAt: admin.firestore.FieldValue.serverTimestamp(),
            status: 'processed'
        });

        return {
            fileId,
            extractedText,
            status: 'success'
        };
    } catch (error) {
        console.error("Document processing error:", error);
        throw new functions.https.HttpsError("internal", "Failed to process document");
    }
});

// Store processed content in knowledge base
export const storeKnowledgeBase = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { fileId, category, tags, userId } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get processed file
        const fileDoc = await db.collection('files').doc(fileId).get();
        if (!fileDoc.exists) {
            throw new functions.https.HttpsError("not-found", "File not found");
        }

        const fileData = fileDoc.data();
        if (!fileData?.extractedText) {
            throw new functions.https.HttpsError("failed-precondition", "File must be processed first");
        }

        // Store in knowledge base collection
        const knowledgeDoc = await db.collection('knowledgeBase').add({
            fileId,
            fileName: fileData.fileName,
            category: category || 'general',
            tags: tags || [],
            content: fileData.extractedText,
            createdBy: userId,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastAccessed: admin.firestore.FieldValue.serverTimestamp(),
            accessCount: 0
        });

        // Update file status
        await db.collection('files').doc(fileId).update({
            knowledgeBaseId: knowledgeDoc.id,
            status: 'stored_in_kb'
        });

        return {
            knowledgeId: knowledgeDoc.id,
            status: 'success'
        };
    } catch (error) {
        console.error("Knowledge base storage error:", error);
        throw new functions.https.HttpsError("internal", "Failed to store in knowledge base");
    }
});

// Delete file and associated knowledge
export const deleteFile = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { fileId } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get file data
        const fileDoc = await db.collection('files').doc(fileId).get();
        if (!fileDoc.exists) {
            throw new functions.https.HttpsError("not-found", "File not found");
        }

        const fileData = fileDoc.data();
        const filePath = fileData?.filePath;
        const knowledgeBaseId = fileData?.knowledgeBaseId;

        // Delete from Storage
        if (filePath) {
            const file = bucket.file(filePath);
            await file.delete();
        }

        // Delete from knowledge base if exists
        if (knowledgeBaseId) {
            await db.collection('knowledgeBase').doc(knowledgeBaseId).delete();
        }

        // Delete file document
        await db.collection('files').doc(fileId).delete();

        return {
            status: 'success',
            message: 'File and associated data deleted successfully'
        };
    } catch (error) {
        console.error("File deletion error:", error);
        throw new functions.https.HttpsError("internal", "Failed to delete file");
    }
});

// Get user's files
export const getUserFiles = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, propertyId } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('files').where('uploadedBy', '==', userId);
        
        if (propertyId) {
            query = query.where('propertyId', '==', propertyId);
        }

        const snapshot = await query.orderBy('uploadedAt', 'desc').get();
        const files = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { files };
    } catch (error) {
        console.error("Get user files error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get user files");
    }
});

// Search knowledge base
export const searchKnowledgeBase = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { query, userId, category } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let knowledgeQuery = db.collection('knowledgeBase').where('createdBy', '==', userId);
        
        if (category) {
            knowledgeQuery = knowledgeQuery.where('category', '==', category);
        }

        const snapshot = await knowledgeQuery.get();
        const results = [];

        for (const doc of snapshot.docs) {
            const data = doc.data();
            const content = data.content.toLowerCase();
            const searchQuery = query.toLowerCase();
            
            if (content.includes(searchQuery)) {
                results.push({
                    id: doc.id,
                    fileName: data.fileName,
                    category: data.category,
                    tags: data.tags,
                    content: data.content.substring(0, 200) + '...',
                    createdAt: data.createdAt
                });
            }
        }

        return { results };
    } catch (error) {
        console.error("Knowledge base search error:", error);
        throw new functions.https.HttpsError("internal", "Failed to search knowledge base");
    }
});

// Process and index knowledge base content
export const processKnowledgeBase = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { fileId, userId, category, tags } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get file document
        const fileDoc = await db.collection('files').doc(fileId).get();
        if (!fileDoc.exists) {
            throw new functions.https.HttpsError("not-found", "File not found");
        }

        const fileData = fileDoc.data();
        const extractedText = fileData?.extractedText;

        if (!extractedText) {
            throw new functions.https.HttpsError("failed-precondition", "File must be processed first");
        }

        // Use Gemini to analyze and structure the content
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const analysisPrompt = `Analyze the following real estate content and extract key information:

Content: ${extractedText}

Please provide:
1. Key topics and themes
2. Important facts and figures
3. Professional terminology used
4. Suggested tags for categorization
5. Summary of main points

Format as JSON with fields: topics, facts, terminology, tags, summary`;

        const result = await model.generateContent(analysisPrompt);
        const response = await result.response;
        const analysis = response.text();

        let structuredData;
        try {
            structuredData = JSON.parse(analysis);
        } catch {
            structuredData = {
                topics: ['real estate', 'property'],
                facts: [],
                terminology: [],
                tags: tags || [],
                summary: extractedText.substring(0, 500)
            };
        }

        // Store in knowledge base with enhanced metadata
        const knowledgeBaseRef = await db.collection('knowledgeBase').add({
            fileId,
            fileName: fileData.fileName,
            category,
            tags: structuredData.tags,
            content: extractedText,
            topics: structuredData.topics,
            facts: structuredData.facts,
            terminology: structuredData.terminology,
            summary: structuredData.summary,
            createdBy: userId,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastAccessed: admin.firestore.FieldValue.serverTimestamp(),
            accessCount: 0,
            status: 'processed'
        });

        // Update file document with knowledge base reference
        await db.collection('files').doc(fileId).update({
            knowledgeBaseId: knowledgeBaseRef.id,
            status: 'indexed'
        });

        return {
            knowledgeId: knowledgeBaseRef.id,
            status: 'success',
            analysis: structuredData
        };
    } catch (error) {
        console.error("Knowledge base processing error:", error);
        throw new functions.https.HttpsError("internal", "Failed to process knowledge base");
    }
});

// Update AI context with new knowledge
export const updateAIContext = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, category, personality } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get user's knowledge base entries
        let query = db.collection('knowledgeBase').where('createdBy', '==', userId);
        if (category) {
            query = query.where('category', '==', category);
        }

        const snapshot = await query.get();
        const knowledgeEntries = snapshot.docs.map((doc: any) => doc.data());

        if (knowledgeEntries.length === 0) {
            return { status: 'no-knowledge', message: 'No knowledge base entries found' };
        }

        // Use Gemini to create personalized AI context
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const contextPrompt = `Based on the following knowledge base entries, create a personalized AI context for a real estate agent with ${personality} personality:

Knowledge Base Entries:
${knowledgeEntries.map(entry => `
File: ${entry.fileName}
Category: ${entry.category}
Content: ${entry.content.substring(0, 1000)}
Tags: ${entry.tags.join(', ')}
`).join('\n')}

Please create:
1. A personalized AI prompt that incorporates this knowledge
2. Key talking points and responses
3. Professional style guidelines
4. Common questions and answers

Format as JSON with fields: prompt, talkingPoints, styleGuidelines, qa`;

        const result = await model.generateContent(contextPrompt);
        const response = await result.response;
        const aiContext = response.text();

        let structuredContext;
        try {
            structuredContext = JSON.parse(aiContext);
        } catch {
            structuredContext = {
                prompt: `You are a helpful real estate assistant with expertise in ${category || 'real estate'}. Use a ${personality} personality.`,
                talkingPoints: [],
                styleGuidelines: [],
                qa: []
            };
        }

        // Store AI context
        const contextRef = await db.collection('aiContexts').add({
            userId,
            category,
            personality,
            context: structuredContext,
            knowledgeBaseIds: knowledgeEntries.map(entry => entry.id),
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUpdated: admin.firestore.FieldValue.serverTimestamp()
        });

        return {
            contextId: contextRef.id,
            status: 'success',
            context: structuredContext
        };
    } catch (error) {
        console.error("AI context update error:", error);
        throw new functions.https.HttpsError("internal", "Failed to update AI context");
    }
});

// Train AI personality based on agent style
export const trainAIPersonality = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, personalityType, trainingData, voiceSettings } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Use Gemini to analyze and create personality profile
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const personalityPrompt = `Create an AI personality profile for a real estate agent based on the following training data:

Personality Type: ${personalityType}
Training Data: ${trainingData}

Voice Settings: ${JSON.stringify(voiceSettings)}

Please create:
1. Personality traits and characteristics
2. Communication style guidelines
3. Response templates for common scenarios
4. Voice and tone recommendations
5. Professional boundaries and ethics

Format as JSON with fields: traits, communicationStyle, responseTemplates, voiceGuidelines, ethics`;

        const result = await model.generateContent(personalityPrompt);
        const response = await result.response;
        const personalityProfile = response.text();

        let structuredProfile;
        try {
            structuredProfile = JSON.parse(personalityProfile);
        } catch {
            structuredProfile = {
                traits: ['professional', 'helpful', 'knowledgeable'],
                communicationStyle: 'clear and concise',
                responseTemplates: [],
                voiceGuidelines: voiceSettings || {},
                ethics: ['honest', 'transparent', 'client-focused']
            };
        }

        // Store personality profile
        const personalityRef = await db.collection('aiPersonalities').add({
            userId,
            personalityType,
            profile: structuredProfile,
            trainingData,
            voiceSettings,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
            status: 'active'
        });

        return {
            personalityId: personalityRef.id,
            status: 'success',
            profile: structuredProfile
        };
    } catch (error) {
        console.error("AI personality training error:", error);
        throw new functions.https.HttpsError("internal", "Failed to train AI personality");
    }
});

// Enhanced AI response with knowledge base context
export const getAIResponseWithContext = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { message, userId, category, personalityType, chatHistory } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get user's AI context and personality
        const [contextSnapshot, personalitySnapshot] = await Promise.all([
            db.collection('aiContexts').where('userId', '==', userId).where('category', '==', category).get(),
            db.collection('aiPersonalities').where('userId', '==', userId).where('personalityType', '==', personalityType).get()
        ]);

        let aiContext = null;
        let personalityProfile = null;

        if (!contextSnapshot.empty) {
            aiContext = contextSnapshot.docs[0].data();
        }

        if (!personalitySnapshot.empty) {
            personalityProfile = personalitySnapshot.docs[0].data();
        }

        // Use Gemini with enhanced context
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        let prompt = `You are a helpful AI assistant for a real estate app.`;

        if (aiContext) {
            prompt += `\n\nAI Context: ${JSON.stringify(aiContext.context)}`;
        }

        if (personalityProfile) {
            prompt += `\n\nPersonality Profile: ${JSON.stringify(personalityProfile.profile)}`;
        }

        prompt += `\n\nChat History: ${(chatHistory || []).map((msg: { sender: string; text: string }) => `${msg.sender}: ${msg.text}`).join('\n')}

User Question: ${message}

Please provide a helpful response that incorporates the AI context and personality:`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();

        return { text };
    } catch (error) {
        console.error("AI response with context error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get AI response");
    }
});

// Create custom AI personality
export const createAIPersonality = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, personalityName, personalityType, traits, communicationStyle, voiceSettings, trainingData } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Use Gemini to enhance personality creation
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const personalityPrompt = `Create a detailed AI personality profile for a real estate agent:

Personality Name: ${personalityName}
Type: ${personalityType}
Traits: ${traits.join(', ')}
Communication Style: ${communicationStyle}
Training Data: ${trainingData}

Please create:
1. Detailed personality characteristics
2. Communication guidelines
3. Response templates for common scenarios
4. Professional boundaries
5. Voice and tone recommendations

Format as JSON with fields: characteristics, guidelines, templates, boundaries, voiceRecommendations`;

        const result = await model.generateContent(personalityPrompt);
        const response = await result.response;
        const enhancedProfile = response.text();

        let structuredProfile;
        try {
            structuredProfile = JSON.parse(enhancedProfile);
        } catch {
            structuredProfile = {
                characteristics: traits,
                guidelines: [communicationStyle],
                templates: [],
                boundaries: ['professional', 'ethical'],
                voiceRecommendations: voiceSettings || {}
            };
        }

        // Store personality
        const personalityRef = await db.collection('aiPersonalities').add({
            userId,
            personalityName,
            personalityType,
            traits,
            communicationStyle,
            voiceSettings,
            trainingData,
            enhancedProfile: structuredProfile,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
            status: 'active',
            isCustom: true
        });

        return {
            personalityId: personalityRef.id,
            status: 'success',
            profile: structuredProfile
        };
    } catch (error) {
        console.error("AI personality creation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to create AI personality");
    }
});

// Generate response using agent's style
export const generateResponse = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, personalityId, message, context: messageContext, responseType } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get personality profile
        const personalityDoc = await db.collection('aiPersonalities').doc(personalityId).get();
        if (!personalityDoc.exists) {
            throw new functions.https.HttpsError("not-found", "Personality not found");
        }

        const personality = personalityDoc.data();
        if (!personality) {
            throw new functions.https.HttpsError("not-found", "Personality data not found");
        }
        
        const enhancedProfile = personality.enhancedProfile;

        // Use Gemini to generate response
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const responsePrompt = `Generate a ${responseType || 'conversational'} response using this AI personality:

Personality Name: ${personality.personalityName}
Type: ${personality.personalityType}
Traits: ${personality.traits.join(', ')}
Communication Style: ${personality.communicationStyle}

Enhanced Profile: ${JSON.stringify(enhancedProfile)}

Context: ${messageContext || 'General conversation'}

User Message: ${message}

Please generate a response that matches the personality's style and characteristics:`;

        const result = await model.generateContent(responsePrompt);
        const response = await result.response;
        const generatedResponse = response.text();

        // Store response for learning
        await db.collection('aiResponses').add({
            userId,
            personalityId,
            originalMessage: message,
            generatedResponse,
            context: messageContext,
            responseType,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        return {
            response: generatedResponse,
            personalityName: personality.personalityName,
            confidence: 0.95
        };
    } catch (error) {
        console.error("Response generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate response");
    }
});

// Save email/message template
export const saveTemplate = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, templateName, templateType, content, variables, category, tags } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Extract variables from content
        const variablePattern = /\{\{([^}]+)\}\}/g;
        const extractedVariables = [];
        let match;
        while ((match = variablePattern.exec(content)) !== null) {
            extractedVariables.push(match[1]);
        }

        // Use Gemini to enhance template
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const templatePrompt = `Analyze this ${templateType} template for a real estate agent:

Template Name: ${templateName}
Content: ${content}
Variables: ${variables.join(', ')}

Please provide:
1. Template effectiveness score (1-10)
2. Suggested improvements
3. Best use cases
4. Professional tone assessment

Format as JSON with fields: effectiveness, improvements, useCases, toneAssessment`;

        const result = await model.generateContent(templatePrompt);
        const response = await result.response;
        const analysis = response.text();

        let templateAnalysis;
        try {
            templateAnalysis = JSON.parse(analysis);
        } catch {
            templateAnalysis = {
                effectiveness: 7,
                improvements: [],
                useCases: ['general'],
                toneAssessment: 'professional'
            };
        }

        // Store template
        const templateRef = await db.collection('templates').add({
            userId,
            templateName,
            templateType,
            content,
            variables: variables || extractedVariables,
            category,
            tags: tags || [],
            analysis: templateAnalysis,
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
            status: 'active',
            usageCount: 0
        });

        return {
            templateId: templateRef.id,
            status: 'success',
            analysis: templateAnalysis
        };
    } catch (error) {
        console.error("Template save error:", error);
        throw new functions.https.HttpsError("internal", "Failed to save template");
    }
});

// Apply template with dynamic data
export const applyTemplate = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { templateId, variables, context: applicationContext } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Get template
        const templateDoc = await db.collection('templates').doc(templateId).get();
        if (!templateDoc.exists) {
            throw new functions.https.HttpsError("not-found", "Template not found");
        }

        const template = templateDoc.data();
        if (!template) {
            throw new functions.https.HttpsError("not-found", "Template data not found");
        }
        
        let content = template.content;

        // Replace variables
        for (const [key, value] of Object.entries(variables || {})) {
            const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
            content = content.replace(placeholder, value as string);
        }

        // Use Gemini to enhance the filled template
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const enhancementPrompt = `Enhance this ${template.templateType} template content for a real estate agent:

Original Template: ${template.content}
Filled Content: ${content}
Context: ${applicationContext || 'General use'}

Please:
1. Improve the flow and readability
2. Ensure professional tone
3. Add any missing context
4. Optimize for the specific use case

Return the enhanced content:`;

        const result = await model.generateContent(enhancementPrompt);
        const response = await result.response;
        const enhancedContent = response.text();

        // Update usage count
        await db.collection('templates').doc(templateId).update({
            usageCount: admin.firestore.FieldValue.increment(1),
            lastUsed: admin.firestore.FieldValue.serverTimestamp()
        });

        // Store application record
        await db.collection('templateApplications').add({
            templateId,
            userId: context.auth.uid,
            originalContent: content,
            enhancedContent,
            variables,
            context: applicationContext,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        return {
            originalContent: content,
            enhancedContent,
            templateName: template.templateName,
            templateType: template.templateType
        };
    } catch (error) {
        console.error("Template application error:", error);
        throw new functions.https.HttpsError("internal", "Failed to apply template");
    }
});

// Get user's templates
export const getUserTemplates = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, templateType, category } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('templates').where('userId', '==', userId);
        
        if (templateType) {
            query = query.where('templateType', '==', templateType);
        }
        
        if (category) {
            query = query.where('category', '==', category);
        }

        const snapshot = await query.orderBy('createdAt', 'desc').get();
        const templates = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { templates };
    } catch (error) {
        console.error("Get user templates error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get templates");
    }
});

// Get user's AI personalities
export const getUserPersonalities = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, personalityType } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('aiPersonalities').where('userId', '==', userId);
        
        if (personalityType) {
            query = query.where('personalityType', '==', personalityType);
        }

        const snapshot = await query.orderBy('createdAt', 'desc').get();
        const personalities = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { personalities };
    } catch (error) {
        console.error("Get user personalities error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get personalities");
    }
});

// Send email using AI-enhanced content
export const sendEmail = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, to, subject, content, templateId, personalityId, variables, priority } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let finalContent = content;
        let finalSubject = subject;

        // Apply template if provided
        if (templateId) {
            const templateDoc = await db.collection('templates').doc(templateId).get();
            if (templateDoc.exists) {
                const template = templateDoc.data();
                if (template) {
                    let templateContent = template.content;
                    
                    // Replace variables
                    for (const [key, value] of Object.entries(variables || {})) {
                        const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
                        templateContent = templateContent.replace(placeholder, value as string);
                    }
                    
                    finalContent = templateContent;
                    finalSubject = finalSubject || template.templateName;
                }
            }
        }

        // Enhance content with AI if personality is provided
        if (personalityId) {
            const personalityDoc = await db.collection('aiPersonalities').doc(personalityId).get();
            if (personalityDoc.exists) {
                const personality = personalityDoc.data();
                if (personality) {
                    const model = genAI.getGenerativeModel({ model: "gemini-pro" });
                    
                    const enhancementPrompt = `Enhance this email content using the AI personality:

Personality: ${personality.personalityName}
Type: ${personality.personalityType}
Traits: ${personality.traits.join(', ')}
Communication Style: ${personality.communicationStyle}

Original Content: ${finalContent}

Please enhance the email to match the personality's style while maintaining professionalism and clarity.`;

                    const result = await model.generateContent(enhancementPrompt);
                    const response = await result.response;
                    finalContent = response.text();
                }
            }
        }

        // Store email record
        const emailRef = await db.collection('emails').add({
            userId,
            to,
            subject: finalSubject,
            content: finalContent,
            templateId,
            personalityId,
            variables,
            priority: priority || 'normal',
            status: 'sent',
            sentAt: admin.firestore.FieldValue.serverTimestamp(),
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        // For now, we'll simulate email sending
        // In production, integrate with SendGrid, Mailgun, or similar service
        console.log(`Email would be sent to: ${to}`);
        console.log(`Subject: ${finalSubject}`);
        console.log(`Content: ${finalContent}`);

        return {
            emailId: emailRef.id,
            status: 'sent',
            message: 'Email sent successfully'
        };
    } catch (error) {
        console.error("Email sending error:", error);
        throw new functions.https.HttpsError("internal", "Failed to send email");
    }
});

// Schedule email for later delivery
export const scheduleEmail = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, to, subject, content, templateId, personalityId, variables, scheduledAt, priority } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Validate scheduled time
        const scheduledTime = new Date(scheduledAt);
        const now = new Date();
        if (scheduledTime <= now) {
            throw new functions.https.HttpsError("invalid-argument", "Scheduled time must be in the future");
        }

        // Store scheduled email
        const emailRef = await db.collection('scheduledEmails').add({
            userId,
            to,
            subject,
            content,
            templateId,
            personalityId,
            variables,
            priority: priority || 'normal',
            scheduledAt: scheduledTime,
            status: 'scheduled',
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        return {
            emailId: emailRef.id,
            status: 'scheduled',
            scheduledAt: scheduledTime,
            message: 'Email scheduled successfully'
        };
    } catch (error) {
        console.error("Email scheduling error:", error);
        throw new functions.https.HttpsError("internal", "Failed to schedule email");
    }
});

// Get email templates with AI suggestions
export const getEmailTemplates = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, category, templateType } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('templates').where('userId', '==', userId);
        
        if (templateType) {
            query = query.where('templateType', '==', templateType);
        }
        
        if (category) {
            query = query.where('category', '==', category);
        }

        const snapshot = await query.orderBy('createdAt', 'desc').get();
        const templates = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        // Get AI suggestions for email templates
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const suggestionsPrompt = `Generate 3 email template suggestions for a real estate agent in the ${category || 'general'} category:

Please provide:
1. Template names
2. Subject lines
3. Content outlines
4. Best use cases

Format as JSON with fields: templates`;

        const result = await model.generateContent(suggestionsPrompt);
        const response = await result.response;
        const suggestions = response.text();

        let aiSuggestions;
        try {
            aiSuggestions = JSON.parse(suggestions);
        } catch {
            aiSuggestions = { templates: [] };
        }

        return {
            templates,
            aiSuggestions: aiSuggestions.templates || []
        };
    } catch (error) {
        console.error("Get email templates error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get email templates");
    }
});

// Track email metrics and analytics
export const trackEmailMetrics = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { emailId, event, recipientEmail, timestamp } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Store email event
        await db.collection('emailEvents').add({
            emailId,
            event, // 'sent', 'delivered', 'opened', 'clicked', 'bounced'
            recipientEmail,
            timestamp: timestamp || admin.firestore.FieldValue.serverTimestamp(),
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        // Update email status if needed
        if (event === 'opened' || event === 'clicked') {
            await db.collection('emails').doc(emailId).update({
                lastActivity: admin.firestore.FieldValue.serverTimestamp(),
                [`metrics.${event}`]: admin.firestore.FieldValue.increment(1)
            });
        }

        return { status: 'tracked' };
    } catch (error) {
        console.error("Email metrics tracking error:", error);
        throw new functions.https.HttpsError("internal", "Failed to track email metrics");
    }
});

// Send bulk emails with personalization
export const sendBulkEmail = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, recipients, subject, content, templateId, personalityId, variables, scheduleAt } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        if (!recipients || recipients.length === 0) {
            throw new functions.https.HttpsError("invalid-argument", "Recipients list is required");
        }

        const results = [];
        const batch = db.batch();

        for (const recipient of recipients) {
            try {
                let personalizedContent = content;
                let personalizedSubject = subject;

                // Personalize content with recipient data
                if (recipient.variables) {
                    for (const [key, value] of Object.entries(recipient.variables)) {
                        const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
                        personalizedContent = personalizedContent.replace(placeholder, value as string);
                        personalizedSubject = personalizedSubject.replace(placeholder, value as string);
                    }
                }

                // Apply template if provided
                if (templateId) {
                    const templateDoc = await db.collection('templates').doc(templateId).get();
                    if (templateDoc.exists) {
                        const template = templateDoc.data();
                        if (template) {
                            let templateContent = template.content;
                            
                            // Replace variables
                            const allVariables = { ...variables, ...recipient.variables };
                            for (const [key, value] of Object.entries(allVariables || {})) {
                                const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
                                templateContent = templateContent.replace(placeholder, value as string);
                            }
                            
                            personalizedContent = templateContent;
                            personalizedSubject = personalizedSubject || template.templateName;
                        }
                    }
                }

                // Create email record
                const emailRef = db.collection('emails').doc();
                batch.set(emailRef, {
                    userId,
                    to: recipient.email,
                    subject: personalizedSubject,
                    content: personalizedContent,
                    templateId,
                    personalityId,
                    variables: { ...variables, ...recipient.variables },
                    priority: 'normal',
                    status: scheduleAt ? 'scheduled' : 'sent',
                    sentAt: scheduleAt ? null : admin.firestore.FieldValue.serverTimestamp(),
                    scheduledAt: scheduleAt ? new Date(scheduleAt) : null,
                    createdAt: admin.firestore.FieldValue.serverTimestamp(),
                    isBulk: true,
                    bulkId: `bulk_${Date.now()}`
                });

                results.push({
                    email: recipient.email,
                    status: 'queued',
                    emailId: emailRef.id
                });

            } catch (error) {
                results.push({
                    email: recipient.email,
                    status: 'failed',
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            }
        }

        // Commit batch
        await batch.commit();

        return {
            status: 'success',
            totalRecipients: recipients.length,
            results
        };
    } catch (error) {
        console.error("Bulk email sending error:", error);
        throw new functions.https.HttpsError("internal", "Failed to send bulk emails");
    }
});

// Get email analytics and reports
export const getEmailAnalytics = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, startDate, endDate } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('emails').where('userId', '==', userId);
        
        if (startDate) {
            query = query.where('createdAt', '>=', new Date(startDate));
        }
        
        if (endDate) {
            query = query.where('createdAt', '<=', new Date(endDate));
        }

        const snapshot = await query.get();
        const emails = snapshot.docs.map((doc: any) => doc.data());

        // Calculate metrics
        const totalEmails = emails.length;
        const sentEmails = emails.filter(email => email.status === 'sent').length;
        const scheduledEmails = emails.filter(email => email.status === 'scheduled').length;
        const openedEmails = emails.reduce((sum, email) => sum + (email.metrics?.opened || 0), 0);
        const clickedEmails = emails.reduce((sum, email) => sum + (email.metrics?.clicked || 0), 0);

        const openRate = totalEmails > 0 ? (openedEmails / totalEmails) * 100 : 0;
        const clickRate = totalEmails > 0 ? (clickedEmails / totalEmails) * 100 : 0;

        // Get recent email events
        const eventsQuery = db.collection('emailEvents')
            .where('emailId', 'in', emails.slice(0, 10).map(email => email.id))
            .orderBy('timestamp', 'desc')
            .limit(50);

        const eventsSnapshot = await eventsQuery.get();
        const recentEvents = eventsSnapshot.docs.map((doc: any) => doc.data());

        return {
            metrics: {
                totalEmails,
                sentEmails,
                scheduledEmails,
                openedEmails,
                clickedEmails,
                openRate: Math.round(openRate * 100) / 100,
                clickRate: Math.round(clickRate * 100) / 100
            },
            recentEvents,
            emails: emails.slice(0, 20) // Return recent emails for detailed view
        };
    } catch (error) {
        console.error("Email analytics error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get email analytics");
    }
});

// Additional security functions for the frontend service

// Get security reports
export const getSecurityReports = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { startDate, endDate, reportType, limit } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        let query: any = db.collection('securityReports');
        
        if (startDate) {
            query = query.where('generatedAt', '>=', new Date(startDate));
        }
        
        if (endDate) {
            query = query.where('generatedAt', '<=', new Date(endDate));
        }
        
        if (reportType) {
            query = query.where('monitoringType', '==', reportType);
        }

        const snapshot = await query
            .orderBy('generatedAt', 'desc')
            .limit(limit || 50)
            .get();

        const reports = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { reports };
    } catch (error) {
        console.error("Get security reports error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get security reports");
    }
});

// Get audit logs
export const getAuditLogs = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, action, resourceType, startDate, endDate, limit } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        let query: any = db.collection('auditLogs');
        
        if (userId) {
            query = query.where('performedBy', '==', userId);
        }
        
        if (action) {
            query = query.where('action', '==', action);
        }
        
        if (resourceType) {
            query = query.where('resourceType', '==', resourceType);
        }
        
        if (startDate) {
            query = query.where('timestamp', '>=', new Date(startDate));
        }
        
        if (endDate) {
            query = query.where('timestamp', '<=', new Date(endDate));
        }

        const snapshot = await query
            .orderBy('timestamp', 'desc')
            .limit(limit || 100)
            .get();

        const auditLogs = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { auditLogs };
    } catch (error) {
        console.error("Get audit logs error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get audit logs");
    }
});

// Get security alerts
export const getSecurityAlerts = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, severity, resolved, limit } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        let query: any = db.collection('securityAlerts');
        
        if (userId) {
            query = query.where('userId', '==', userId);
        }

        const snapshot = await query.get();
        const interactions = snapshot.docs.map(doc => doc.data());

        return {
            success: true,
            reportType,
            data: interactions,
            generatedAt: new Date().toISOString()
        };
    } catch (error) {
        console.error("Report generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate report");
    }
});

        if (severity) {
            query = query.where('severity', '==', severity);
        }
        
        if (resolved !== undefined) {
            query = query.where('resolved', '==', resolved);
        }

        const snapshot = await query
            .orderBy('timestamp', 'desc')
            .limit(limit || 50)
            .get();

        const alerts = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { alerts };
    } catch (error) {
        console.error("Get security alerts error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get security alerts");
    }
});

// Resolve security alert
export const resolveSecurityAlert = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { alertId, resolution } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        if (!alertId) {
            throw new functions.https.HttpsError("invalid-argument", "Alert ID is required");
        }

        // Update alert
        await db.collection('securityAlerts').doc(alertId).update({
            resolved: true,
            resolvedBy: requestingUserId,
            resolvedAt: admin.firestore.FieldValue.serverTimestamp(),
            resolution: resolution || 'Resolved by administrator'
        });

        // Log resolution
        await logAuditAction({
            action: 'security_alert_resolved',
            resourceType: 'securityAlert',
            resourceId: alertId,
            details: { resolution },
            severity: 'info'
        }, context);

        return { success: true, message: 'Security alert resolved successfully' };
    } catch (error) {
        console.error("Resolve security alert error:", error);
        throw new functions.https.HttpsError("internal", "Failed to resolve security alert");
    }
});

// Get backup history
export const getBackupHistory = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { backupType, status, limit } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        let query: any = db.collection('backups');
        
        if (backupType) {
            query = query.where('backupType', '==', backupType);
        }
        
        if (status) {
            query = query.where('status', '==', status);
        }

        const snapshot = await query
            .orderBy('startTime', 'desc')
            .limit(limit || 20)
            .get();

        const backups = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { backups };
    } catch (error) {
        console.error("Get backup history error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get backup history");
    }
});

// Get restore history
export const getRestoreHistory = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { restoreMode, status, limit } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        const requestingUserId = context.auth.uid;
        
        // Check admin permissions
        const userDoc = await db.collection('users').doc(requestingUserId).get();
        const userData = userDoc.data();
        if (userData?.role !== 'admin') {
            throw new functions.https.HttpsError("permission-denied", "Admin access required");
        }

        let query: any = db.collection('restores');
        
        if (restoreMode) {
            query = query.where('restoreMode', '==', restoreMode);
        }
        
        if (status) {
            query = query.where('status', '==', status);
        }

        const snapshot = await query
            .orderBy('startTime', 'desc')
            .limit(limit || 20)
            .get();

        const restores = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        return { restores };
    } catch (error) {
        console.error("Get restore history error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get restore history");
    }
});

// Sync existing email conversations
export const syncEmail = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, emailProvider, syncOptions } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        // Validate email provider
        const supportedProviders = ['gmail', 'outlook', 'yahoo', 'imap'];
        if (!supportedProviders.includes(emailProvider)) {
            throw new functions.https.HttpsError("invalid-argument", "Unsupported email provider");
        }

        // Use Gemini to analyze and structure imported emails
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const analysisPrompt = `Analyze these email conversations for a real estate agent and extract key information:

Email Provider: ${emailProvider}
Sync Options: ${JSON.stringify(syncOptions)}

Please provide:
1. Key conversation themes and topics
2. Client interaction patterns
3. Important dates and follow-ups
4. Property-related discussions
5. Communication style insights

Format as JSON with fields: themes, patterns, dates, properties, insights`;

        const result = await model.generateContent(analysisPrompt);
        const response = await result.response;
        const analysis = response.text();

        let emailAnalysis;
        try {
            emailAnalysis = JSON.parse(analysis);
        } catch {
            emailAnalysis = {
                themes: [],
                patterns: [],
                dates: [],
                properties: [],
                insights: []
            };
        }

        // Store sync configuration
        const syncRef = await db.collection('emailSyncs').add({
            userId,
            emailProvider,
            credentials: {
                // Store encrypted credentials (in production, use proper encryption)
                provider: emailProvider,
                lastSync: admin.firestore.FieldValue.serverTimestamp()
            },
            syncOptions,
            analysis: emailAnalysis,
            status: 'syncing',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUpdated: admin.firestore.FieldValue.serverTimestamp()
        });

        // Simulate email import (in production, integrate with actual email APIs)
        const importedEmails = [
            {
                id: `imported_${Date.now()}_1`,
                from: 'client@example.com',
                to: 'agent@example.com',
                subject: 'Property Viewing Request',
                content: 'Hi, I would like to schedule a viewing for the property at 123 Main St.',
                date: new Date(Date.now() - 86400000), // 1 day ago
                threadId: 'thread_1',
                labels: ['client', 'viewing-request']
            },
            {
                id: `imported_${Date.now()}_2`,
                from: 'agent@example.com',
                to: 'client@example.com',
                subject: 'Re: Property Viewing Request',
                content: 'Great! I can schedule a viewing for tomorrow at 2 PM. Does that work for you?',
                date: new Date(Date.now() - 82800000), // 23 hours ago
                threadId: 'thread_1',
                labels: ['agent', 'viewing-confirmation']
            }
        ];

        // Store imported emails
        const batch = db.batch();
        importedEmails.forEach(email => {
            const emailRef = db.collection('importedEmails').doc();
            batch.set(emailRef, {
                userId,
                syncId: syncRef.id,
                ...email,
                importedAt: admin.firestore.FieldValue.serverTimestamp(),
                status: 'imported'
            });
        });

        await batch.commit();

        // Update sync status
        await db.collection('emailSyncs').doc(syncRef.id).update({
            status: 'completed',
            importedCount: importedEmails.length,
            lastUpdated: admin.firestore.FieldValue.serverTimestamp()
        });

        return {
            syncId: syncRef.id,
            status: 'completed',
            importedCount: importedEmails.length,
            analysis: emailAnalysis,
            message: `Successfully imported ${importedEmails.length} emails from ${emailProvider}`
        };
    } catch (error) {
        console.error("Email sync error:", error);
        throw new functions.https.HttpsError("internal", "Failed to sync emails");
    }
});

// Get synced email conversations
export const getSyncedEmails = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, syncId, threadId, startDate, endDate } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query = db.collection('importedEmails').where('userId', '==', userId);
        
        if (syncId) {
            query = query.where('syncId', '==', syncId);
        }
        
        if (threadId) {
            query = query.where('threadId', '==', threadId);
        }
        
        if (startDate) {
            query = query.where('date', '>=', new Date(startDate));
        }
        
        if (endDate) {
            query = query.where('date', '<=', new Date(endDate));
        }

        const snapshot = await query.orderBy('date', 'desc').get();
        const emails = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        // Group by thread
        const threads = emails.reduce((acc, email: any) => {
            if (!acc[email.threadId]) {
                acc[email.threadId] = [];
            }
            acc[email.threadId].push(email);
            return acc;
        }, {} as any);

        return {
            emails,
            threads,
            totalEmails: emails.length,
            totalThreads: Object.keys(threads).length
        };
    } catch (error) {
        console.error("Get synced emails error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get synced emails");
    }
});

// Generate AI Questions for Interactive Forms
export const generateAIQuestions = functions.https.onCall(async (data: any, context) => {
    try {
        const { type, userId } = data;
        
        if (!type || !userId) {
            throw new functions.https.HttpsError("invalid-argument", "Type and user ID are required");
        }

        // Use Gemini to generate contextual questions
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Generate 8-10 intelligent questions for a real estate marketing proposal form. The questions should be:

1. Property Address (text input)
2. Property Type (select: Residential Home, Condo/Apartment, Townhouse, Luxury Home, Investment Property, Land, Commercial)
3. Property Price (text input)
4. Special Features (textarea - optional)
5. Target Market (multi-select: First-time buyers, Families, Professionals, Investors, Luxury buyers, Downsizers, All buyers)
6. Agent Name (text input)
7. Agent Experience (select: 1-3 years, 3-5 years, 5-10 years, 10+ years)
8. Custom Requirements (textarea - optional)

Return the questions as a JSON array with this structure:
[{
  "id": "question_id",
  "question": "Question text?",
  "type": "text|select|textarea|multi-select",
  "options": ["option1", "option2"] (for select/multi-select),
  "required": true/false,
  "placeholder": "placeholder text"
}]

Make the questions conversational and professional.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const questionsText = response.text();

        // Parse the JSON response
        let questions;
        try {
            questions = JSON.parse(questionsText);
        } catch (parseError) {
            // Fallback to default questions if parsing fails
            questions = [
                {
                    id: 'property_address',
                    question: 'What is the property address?',
                    type: 'text',
                    required: true,
                    placeholder: 'e.g., 123 Main Street, City, State'
                },
                {
                    id: 'property_type',
                    question: 'What type of property is this?',
                    type: 'select',
                    options: ['Residential Home', 'Condo/Apartment', 'Townhouse', 'Luxury Home', 'Investment Property', 'Land', 'Commercial'],
                    required: true
                },
                {
                    id: 'property_price',
                    question: 'What is the asking price or price range?',
                    type: 'text',
                    required: true,
                    placeholder: 'e.g., $450,000 or $400,000 - $500,000'
                },
                {
                    id: 'special_features',
                    question: 'What special features or unique selling points should we highlight?',
                    type: 'textarea',
                    required: false,
                    placeholder: 'e.g., Recently renovated kitchen, large backyard, great schools nearby, etc.'
                },
                {
                    id: 'target_market',
                    question: 'Who is your target market for this property?',
                    type: 'multi-select',
                    options: ['First-time buyers', 'Families', 'Professionals', 'Investors', 'Luxury buyers', 'Downsizers', 'All buyers'],
                    required: true
                },
                {
                    id: 'agent_name',
                    question: 'What is your name?',
                    type: 'text',
                    required: true,
                    placeholder: 'Your full name'
                },
                {
                    id: 'agent_experience',
                    question: 'How many years of real estate experience do you have?',
                    type: 'select',
                    options: ['1-3 years', '3-5 years', '5-10 years', '10+ years'],
                    required: true
                },
                {
                    id: 'custom_requirements',
                    question: 'Any specific requirements or preferences for the marketing proposal?',
                    type: 'textarea',
                    required: false,
                    placeholder: 'e.g., Focus on digital marketing, emphasize luxury features, target specific neighborhood, etc.'
                }
            ];
        }

        console.log(`AI questions generated for type: ${type}`);
        
        return { 
            success: true, 
            questions
        };
    } catch (error) {
        console.error("AI questions generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate AI questions");
    }
});

// Generate Marketing Proposal
export const generateMarketingProposal = functions.https.onCall(async (data: any, context) => {
    try {
        const { propertyAddress, propertyPrice, propertyType, agentInfo, customRequirements, userId } = data;
        
        if (!propertyAddress || !agentInfo?.name || !userId) {
            throw new functions.https.HttpsError("invalid-argument", "Property address, agent name, and user ID are required");
        }

        // Use Gemini to generate the proposal
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });
        
        const prompt = `Create a professional real estate marketing proposal for the following property and agent:

Property Details:
- Address: ${propertyAddress}
- Price: ${propertyPrice || 'TBD'}
- Type: ${propertyType}

Agent Information:
- Name: ${agentInfo.name}
- Email: ${agentInfo.email || 'N/A'}
- Phone: ${agentInfo.phone || 'N/A'}
- Experience: ${agentInfo.experience}

Custom Requirements: ${customRequirements || 'None specified'}

Please create a comprehensive marketing proposal with the following sections:
1. Executive Summary (2-3 sentences)
2. Market Analysis (brief market overview)
3. Pricing Strategy (recommended approach)
4. Marketing Plan (multi-channel strategy)
5. Timeline (30-day campaign outline)

Make it professional, concise, and actionable. Each section should be 1-2 sentences.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const proposalText = response.text();

        // Parse the response into sections
        const sections = proposalText.split('\n\n');
        const proposal = {
            id: `proposal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            propertyAddress,
            propertyPrice,
            propertyType,
            agentInfo,
            customRequirements,
            executiveSummary: sections[0]?.replace('Executive Summary:', '').trim() || 'Professional marketing proposal for this property.',
            marketAnalysis: sections[1]?.replace('Market Analysis:', '').trim() || 'Current market analysis shows strong potential.',
            pricingStrategy: sections[2]?.replace('Pricing Strategy:', '').trim() || 'Competitive pricing strategy recommended.',
            marketingPlan: sections[3]?.replace('Marketing Plan:', '').trim() || 'Multi-channel marketing approach.',
            timeline: sections[4]?.replace('Timeline:', '').trim() || '30-day marketing campaign.',
            userId,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        };

        // Save to Firestore
        await db.collection('marketingProposals').doc(proposal.id).set(proposal);

        console.log(`Marketing proposal generated: ${proposal.id} for ${propertyAddress}`);
        
        return { 
            success: true, 
            proposalId: proposal.id,
            proposal
        };
    } catch (error) {
        console.error("Marketing proposal generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate marketing proposal");
    }
});

// QR Code Tracking System Functions

// Track QR code scans
export const trackQRScan = functions.https.onCall(async (data: any, context) => {
    try {
        const { qrCodeId, userId, userAgent, location, timestamp } = data;
        
        if (!qrCodeId) {
            throw new functions.https.HttpsError("invalid-argument", "QR code ID is required");
        }

        const scanData = {
            qrCodeId,
            userId: userId || 'anonymous',
            userAgent: userAgent || '',
            location: location || null,
            timestamp: timestamp || admin.firestore.FieldValue.serverTimestamp(),
            ipAddress: '',
            userEmail: null
        };

        // Save scan record
        await db.collection('qrScans').add(scanData);

        // Update QR code analytics
        const qrCodeRef = db.collection('qrCodes').doc(qrCodeId);
        await qrCodeRef.update({
            totalScans: admin.firestore.FieldValue.increment(1),
            lastScanned: admin.firestore.FieldValue.serverTimestamp()
        });

        console.log(`QR scan tracked: ${qrCodeId} by ${userId || 'anonymous'}`);
        
        return { success: true, scanId: scanData.timestamp };
    } catch (error) {
        console.error("QR scan tracking error:", error);
        throw new functions.https.HttpsError("internal", "Failed to track QR scan");
    }
});

// Generate custom QR codes
export const generateQRCode = functions.https.onCall(async (data: any, context) => {
    try {
        const { destination, title, description, userId, customData } = data;
        
        if (!destination || !userId) {
            throw new functions.https.HttpsError("invalid-argument", "Destination URL and user ID are required");
        }

        // Generate unique QR code ID
        const qrCodeId = `qr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Create QR code data
        const qrCodeData = {
            id: qrCodeId,
            destination,
            title: title || 'Custom QR Code',
            description: description || '',
            userId,
            customData: customData || {},
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            totalScans: 0,
            isActive: true,
            metadata: {
                createdBy: userId,
                userAgent: '',
                ipAddress: ''
            }
        };

        // Save QR code to database
        await db.collection('qrCodes').doc(qrCodeId).set(qrCodeData);

        // Generate QR code URL (in production, you'd use a QR code generation library)
        const qrCodeUrl = `https://your-domain.com/qr/${qrCodeId}`;
        
        console.log(`QR code generated: ${qrCodeId} for ${destination}`);
        
        return { 
            success: true, 
            qrCodeId, 
            qrCodeUrl,
            destination,
            title: qrCodeData.title
        };
    } catch (error) {
        console.error("QR code generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate QR code");
    }
});

// Get QR code analytics
export const getQRAnalytics = functions.https.onCall(async (data: any, context) => {
    try {
        const { qrCodeId, userId, timeRange } = data;
        
        if (!userId) {
            throw new functions.https.HttpsError("invalid-argument", "User ID is required");
        }

        let query: any = db.collection('qrScans');
        
        // Filter by QR code if specified
        if (qrCodeId) {
            query = query.where('qrCodeId', '==', qrCodeId);
        }
        
        // Filter by time range if specified
        if (timeRange) {
            const startDate = new Date();
            switch (timeRange) {
                case '24h':
                    startDate.setHours(startDate.getHours() - 24);
                    break;
                case '7d':
                    startDate.setDate(startDate.getDate() - 7);
                    break;
                case '30d':
                    startDate.setDate(startDate.getDate() - 30);
                    break;
                case '90d':
                    startDate.setDate(startDate.getDate() - 90);
                    break;
                default:
                    break;
            }
            query = query.where('timestamp', '>=', startDate);
        }

        const snapshot = await query.get();
        const scans = snapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        // Get QR codes for this user
        const qrCodesSnapshot = await db.collection('qrCodes')
            .where('userId', '==', userId)
            .get();
        
        const qrCodes = qrCodesSnapshot.docs.map((doc: any) => ({
            id: doc.id,
            ...doc.data()
        }));

        // Calculate analytics
        const totalScans = scans.length;
        const uniqueUsers = new Set(scans.map((scan: any) => scan.userId)).size;
        const scansByDate = scans.reduce((acc: any, scan: any) => {
            const date = new Date(scan.timestamp.toDate()).toDateString();
            acc[date] = (acc[date] || 0) + 1;
            return acc;
        }, {});

        const topQRCodes = qrCodes
            .sort((a: any, b: any) => (b.totalScans || 0) - (a.totalScans || 0))
            .slice(0, 10);

        console.log(`QR analytics retrieved for user: ${userId}`);
        
        return {
            success: true,
            analytics: {
                totalScans,
                uniqueUsers,
                scansByDate,
                topQRCodes,
                totalQRCodes: qrCodes.length
            },
            scans: scans.slice(0, 100) // Limit scan history
        };
    } catch (error) {
        console.error("QR analytics error:", error);
        throw new functions.https.HttpsError("internal", "Failed to get QR analytics");
    }
});

// Update QR code destination
export const updateQRDestination = functions.https.onCall(async (data: any, context) => {
    try {
        const { qrCodeId, newDestination, userId } = data;
        
        if (!qrCodeId || !newDestination || !userId) {
            throw new functions.https.HttpsError("invalid-argument", "QR code ID, new destination, and user ID are required");
        }

        // Verify ownership
        const qrCodeDoc = await db.collection('qrCodes').doc(qrCodeId).get();
        if (!qrCodeDoc.exists) {
            throw new functions.https.HttpsError("not-found", "QR code not found");
        }

        const qrCodeData = qrCodeDoc.data();
        if (qrCodeData?.userId !== userId) {
            throw new functions.https.HttpsError("permission-denied", "You don't have permission to update this QR code");
        }

        // Update destination
        await db.collection('qrCodes').doc(qrCodeId).update({
            destination: newDestination,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            'metadata.lastUpdatedBy': userId
        });

        // Log the change
        if (qrCodeData) {
            await db.collection('qrCodeHistory').add({
                qrCodeId,
                action: 'destination_updated',
                oldDestination: qrCodeData.destination,
                newDestination,
                userId,
                timestamp: admin.firestore.FieldValue.serverTimestamp()
            });
        }

        console.log(`QR destination updated: ${qrCodeId} to ${newDestination}`);
        
        return { 
            success: true, 
            qrCodeId, 
            newDestination,
            message: 'QR code destination updated successfully'
        };
    } catch (error) {
        console.error("QR destination update error:", error);
        throw new functions.https.HttpsError("internal", "Failed to update QR destination");
    }
});

// ========================================
// ANALYTICS & REPORTING SYSTEM
// ========================================

// Track user interactions
export const trackInteraction = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, eventType, eventData, propertyId, sessionId, timestamp } = data;
        
        if (!eventType) {
            throw new functions.https.HttpsError("invalid-argument", "Event type is required");
        }

        const interactionData = {
            userId: userId || context?.auth?.uid || 'anonymous',
            eventType, // 'page_view', 'property_view', 'contact_form', 'phone_call', 'email_sent', 'appointment_scheduled', 'favorite_added', 'share_property'
            eventData: eventData || {},
            propertyId: propertyId || null,
            sessionId: sessionId || `session_${Date.now()}`,
            timestamp: timestamp || admin.firestore.FieldValue.serverTimestamp(),
            userAgent: eventData?.userAgent || '',
            ipAddress: eventData?.ipAddress || '',
            location: eventData?.location || null,
            referrer: eventData?.referrer || '',
            utmSource: eventData?.utmSource || '',
            utmMedium: eventData?.utmMedium || '',
            utmCampaign: eventData?.utmCampaign || ''
        };

        // Save interaction to Firestore
        const interactionRef = await db.collection('userInteractions').add(interactionData);

        // Update real-time analytics
        const analyticsRef = db.collection('analytics').doc('realtime');
        await analyticsRef.set({
            lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
            [`events.${eventType}`]: admin.firestore.FieldValue.increment(1),
            [`sessions.${interactionData.sessionId}`]: {
                lastActivity: admin.firestore.FieldValue.serverTimestamp(),
                eventCount: admin.firestore.FieldValue.increment(1)
            }
        }, { merge: true });

        // Update property-specific analytics if propertyId is provided
        if (propertyId) {
            const propertyAnalyticsRef = db.collection('propertyAnalytics').doc(propertyId);
            await propertyAnalyticsRef.set({
                propertyId,
                lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
                [`events.${eventType}`]: admin.firestore.FieldValue.increment(1),
                totalInteractions: admin.firestore.FieldValue.increment(1)
            }, { merge: true });
        }

        console.log(`Interaction tracked: ${eventType} for user ${interactionData.userId}`);
        
        return { 
            success: true, 
            interactionId: interactionRef.id,
            timestamp: interactionData.timestamp
        };
    } catch (error) {
        console.error("Interaction tracking error:", error);
        throw new functions.https.HttpsError("internal", "Failed to track interaction");
    }
});

// Calculate metrics and conversion rates
export const calculateMetrics = functions.https.onCall(async (data: any, context: any) => {
    try {
        const { userId, propertyId, startDate, endDate } = data;
        
        if (!context?.auth) {
            throw new functions.https.HttpsError("unauthenticated", "User must be authenticated");
        }

        let query: any = db.collection('userInteractions');
        
        // Apply filters
        if (userId) {
            query = query.where('userId', '==', userId);
        }

        const snapshot = await query.get();
        const interactions = snapshot.docs.map(doc => doc.data());

        return {
            success: true,
            reportType,
            data: interactions,
            generatedAt: new Date().toISOString()
        };
    } catch (error) {
        console.error("Report generation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to generate report");
    }
});

        if (propertyId) {
            query = query.where('propertyId', '==', propertyId);
        }
        
        if (startDate) {
            query = query.where('timestamp', '>=', new Date(startDate));
        }
        
        if (endDate) {
            query = query.where('timestamp', '<=', new Date(endDate));
        }

        const snapshot = await query.get();
        const interactions = snapshot.docs.map((doc: any) => doc.data());

        // Calculate basic metrics
        const totalInteractions = interactions.length;
        const uniqueUsers = new Set(interactions.map((i: any) => i.userId)).size;
        const uniqueSessions = new Set(interactions.map((i: any) => i.sessionId)).size;

        // Event type breakdown
        const eventBreakdown = interactions.reduce((acc: any, interaction: any) => {
            const eventType = interaction.eventType;
            acc[eventType] = (acc[eventType] || 0) + 1;
            return acc;
        }, {});

        // Conversion funnel analysis
        const funnelSteps = ['page_view', 'property_view', 'contact_form', 'appointment_scheduled'];
        const funnelData = funnelSteps.map(step => ({
            step,
            count: eventBreakdown[step] || 0
        }));

        // Calculate conversion rates
        const conversionRates: any = {};
        for (let i = 1; i < funnelData.length; i++) {
            const currentStep = funnelData[i];
            const previousStep = funnelData[i - 1];
            if (previousStep.count > 0) {
                conversionRates[`${previousStep.step}_to_${currentStep.step}`] = 
                    Math.round((currentStep.count / previousStep.count) * 100 * 100) / 100;
            }
        }

        // Time-based analysis
        const hourlyBreakdown = interactions.reduce((acc: any, interaction: any) => {
            const hour = new Date(interaction.timestamp.toDate()).getHours();
            acc[hour] = (acc[hour] || 0) + 1;
            return acc;
        }, {});

        const dailyBreakdown = interactions.reduce((acc: any, interaction: any) => {
            const date = new Date(interaction.timestamp.toDate()).toDateString();
            acc[date] = (acc[date] || 0) + 1;
            return acc;
        }, {});

        // Property performance (if propertyId is specified)
        let propertyMetrics = null;
        if (propertyId) {
            const propertyAnalyticsDoc = await db.collection('propertyAnalytics').doc(propertyId).get();
            if (propertyAnalyticsDoc.exists) {
                propertyMetrics = propertyAnalyticsDoc.data();
            }
        }

        // User engagement score
        const userEngagement = interactions.reduce((score: any, interaction: any) => {
            const eventScores: any = {
                'page_view': 1,
                'property_view': 3,
                'contact_form': 10,
                'phone_call': 15,
                'email_sent': 8,
                'appointment_scheduled': 20,
                'favorite_added': 5,
                'share_property': 7
            };
            return score + (eventScores[interaction.eventType] || 1);
        }, 0);

        const calculatedMetrics = {
            overview: {
                totalInteractions,
                uniqueUsers,
                uniqueSessions,
                averageInteractionsPerUser: totalInteractions > 0 ? Math.round((totalInteractions / uniqueUsers) * 100) / 100 : 0,
                averageInteractionsPerSession: totalInteractions > 0 ? Math.round((totalInteractions / uniqueSessions) * 100) / 100 : 0
            },
            eventBreakdown,
            funnelData,
            conversionRates,
            timeAnalysis: {
                hourly: hourlyBreakdown,
                daily: dailyBreakdown
            },
            userEngagement,
            propertyMetrics,
            calculatedAt: admin.firestore.FieldValue.serverTimestamp()
        };

        // Store calculated metrics
        const metricsRef = await db.collection('calculatedMetrics').add({
            userId: context.auth.uid,
            propertyId,
            startDate,
            endDate,
            metrics: calculatedMetrics,
            createdAt: admin.firestore.FieldValue.serverTimestamp()
        });

        console.log(`Metrics calculated for user: ${context.auth.uid}`);
        
        return {
            success: true,
            metricsId: metricsRef.id,
            metrics: calculatedMetrics
        };
    } catch (error) {
        console.error("Metrics calculation error:", error);
        throw new functions.https.HttpsError("internal", "Failed to calculate metrics");
    }
});

// Export the API
export { api } from './api';