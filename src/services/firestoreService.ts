import { db } from './firebase';
import { collection, addDoc, getDocs, query, where, Timestamp } from 'firebase/firestore';
import { Property, isAIDescription, AIDescription, AgentProfile } from '../types';

/**
 * Adds a new property document to Firestore.
 * @param propertyData The property data to save. The 'id' will be auto-generated by Firestore.
 * @param userId The ID of the user who owns this property.
 */
export const addProperty = async (propertyData: Omit<Property, 'id'>, userId: string): Promise<string> => {
  try {
    // Sanitize photo arrays to ensure only strings are saved, preventing circular reference errors with File objects.
    const sanitizedHeroPhotos = (propertyData.heroPhotos || [])
      .map(p => (typeof p === 'string' ? p : (p as File).name))
      .filter(Boolean);

    const sanitizedGalleryPhotos = (propertyData.galleryPhotos || [])
      .map(p => (typeof p === 'string' ? p : (p as File).name))
      .filter(Boolean);
      
    // Rebuild agent object to ensure it's a plain, serializable object.
    const { name, title, company, phone, email, headshotUrl, socials, brandColor, logoUrl, website, bio } = propertyData.agent;
    const sanitizedAgent = { name, title, company, phone, email, headshotUrl, socials, brandColor, logoUrl, website, bio };

    // Rebuild description object to ensure it's serializable.
    const sanitizedDescription = isAIDescription(propertyData.description)
        ? { title: propertyData.description.title, paragraphs: propertyData.description.paragraphs }
        : propertyData.description;

    const dataToSave = {
      title: propertyData.title,
      address: propertyData.address,
      price: propertyData.price,
      beds: propertyData.beds,
      baths: propertyData.baths,
      sqft: propertyData.sqft,
      description: sanitizedDescription,
      heroPhotos: sanitizedHeroPhotos,
      galleryPhotos: sanitizedGalleryPhotos,
      appFeatures: propertyData.appFeatures,
      agent: sanitizedAgent,
      propertyType: propertyData.propertyType,
      features: propertyData.features,
      imageUrl: propertyData.imageUrl,
      userId: userId,
      createdAt: Timestamp.now(),
    };

    const docRef = await addDoc(collection(db, 'properties'), dataToSave);
    return docRef.id;
  } catch (error) {
    console.error("Error adding document: ", error);
    throw new Error("Could not save property.");
  }
};

/**
 * Fetches all properties for a given user from Firestore.
 * @param userId The ID of the user whose properties to fetch.
 * @returns A promise that resolves to an array of properties.
 */
export const getProperties = async (userId: string): Promise<Property[]> => {
  try {
    const propertiesCol = collection(db, 'properties');
    const q = query(propertiesCol, where("userId", "==", userId));
    const querySnapshot = await getDocs(q);
    
    const properties: Property[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      // Ensure we have all required Property fields
      if (data && 
          typeof data.title === 'string' &&
          typeof data.address === 'string' &&
          typeof data.price === 'number' &&
          typeof data.beds === 'number' &&
          typeof data.baths === 'number' &&
          typeof data.sqft === 'number') {
        properties.push({
          id: doc.id,
          ...data,
          // Ensure proper typing of nested objects
          agent: data.agent as AgentProfile,
          description: data.description as string | AIDescription,
          heroPhotos: Array.isArray(data.heroPhotos) ? data.heroPhotos : [],
          galleryPhotos: Array.isArray(data.galleryPhotos) ? data.galleryPhotos : [],
          features: Array.isArray(data.features) ? data.features : [],
        } as Property);
      }
    });
    
    return properties;
  } catch (error) {
    console.error("Error getting documents: ", error);
    throw new Error("Could not fetch properties.");
  }
};